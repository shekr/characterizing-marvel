<!-- Based on http://bl.ocks.org/dbuezas/9306799 example -->
<!DOCTYPE html>
<meta charset="utf-8">
<link type="text/css" rel="stylesheet" href="css/vis.css" />
<body>
<script src="http://d3js.org/d3.v3.js"></script>
<script src="js/names.js"></script>

<script>
var svg = d3.select("body")
	.append("svg");

svg.append("g")
	.attr("class", "chordsBox");
svg.append("g")
	.attr("class", "pieSliceBox");

var page = d3.select('body').node().getBoundingClientRect();

var width = 750,
    height = 750,
	radius = Math.min(width, height) / 2;

var innerPieRadius = radius*.9;
var outerTextRadius = radius*1.2;
var innerArcLineRadius = radius*.8;

var pie = d3.layout.pie()
	.sort(null)
	.value(function(d) {
		return d.value;
	});
	

var arc = d3.svg.arc()
	.outerRadius(radius)
	.innerRadius(innerPieRadius);

var textArc = d3.svg.arc()
	.innerRadius(radius)
	.outerRadius(outerTextRadius);
	
var outsideArc = d3.svg.arc()
	.outerRadius(radius)
	.innerRadius(radius);
	
var insideArc = d3.svg.arc()
	.outerRadius(innerPieRadius)
	.innerRadius(innerPieRadius);
	
var insideArcLineArc = d3.svg.arc()
	.outerRadius(innerArcLineRadius)
	.innerRadius(innerArcLineRadius);
	
var arcLine = d3.svg.line()
    .x(function(d) { return d[0] })
    .y(function(d) { return d[1]; })
    .interpolate("bundle")
	.tension(.7);
	
svg.attr("transform", "translate(" + (page.width - width)/2 + "," + (page.height-height)/ 2 + ")");
svg.select('g.chordsBox').attr("transform", "translate(" + radius + ", " + radius + ")");

var key = function(d){ return d.data.label; };

var dataLength = 300;

function getData (){
	var labels = marvelNames.slice(0, dataLength);
	dataLength = labels.length;
	return labels.map(function(label){
		return { label: label, value: 1 }
	});
}

/*var matrixData = [];
function generateRandomMatrix() {	
	for (var i = 0; i < dataLength; i++) {
		var matrixRow = [];
		for (var j = 0; j < dataLength; j++) {
			if (Math.floor(Math.random()*300) == 199) {
				matrixRow[j] = .1;
			} else {
				matrixRow[j] = 0;	
			}
		}
		matrixData.push(matrixRow);
	}
}
*/
//generateRandomMatrix();

function getClassName(nameString) {
	return nameString.replace(/[ '\-()\.]+/g, "");
}

var initData = getData();
//create some random connection data
var connectionsRandom = [];
var connectionTypes = ["family", "standard", "kill"];
for (var i = 0; i < dataLength; i++) {
	for (var j = 0; j <	dataLength; j++) {
		var valR = Math.floor(Math.random()*dataLength);
		if (valR % 200 == 0) {
			var charConnections = {};
			charConnections.id1 = marvelNames[i];
			var indexR = Math.floor(Math.random()*dataLength);
			charConnections.id2 = marvelNames[indexR];
			var indexConn = Math.floor(Math.random()*connectionTypes.length);
			charConnections.type = connectionTypes[indexConn];
			connectionsRandom.push(charConnections);	
		}
	}
}

console.log(connectionsRandom);

updateData(initData, connectionsRandom);



function updateData(data, connections) {
	
	/* ------- PIE SLICES -------*/
	var sliceParents = svg.select('g.pieSliceBox').selectAll("g")
		.data(pie(data), key)
		.enter()
		.append("g")
		.attr("transform", "translate(" + radius + ", " + radius + ")")
		.attr("id", function(d, i) {
			return "sliceGroup-" + getClassName(d.data.label);
		});

	sliceParents.append("path")
		.attr('d', arc)
		//.attr('title', key)
		.attr("fill", function(d) { 
			var val = Math.random();
			if (val > .5)
				return '#4f649d';
			else
				return '#d72829';		
			//return  color(d.data.label); 
		
		})
		.attr("class", "slice");

	/** EVENTS **/
	var slices = svg.select('g.pieSliceBox').selectAll('g');
	
	slices.on('mouseover', function(d){
		//slice and label
		var nodeSelection = d3.select(this);
		var charID = nodeSelection.attr("id").replace('sliceGroup-', '');
		nodeSelection.classed('active', true);
		svg.select('g.chordsBox').selectAll('.chord-' + charID).classed('active', true); //chords		
	})
	
	slices.on('mouseout', function(d){
		//slice and label
    	var nodeSelection = d3.select(this);
		nodeSelection.classed('active', false);
		var charID = nodeSelection.attr("id").replace('sliceGroup-', '');
		svg.select('g.chordsBox').selectAll('.chord-' + charID).classed('active', false); //chords

	})
	
	slices.on('click', function(d){
		var nodeSelection = d3.select(this);
		var selectedState = nodeSelection.classed('selected');
		var coreState = nodeSelection.classed('core');
		var charID = nodeSelection.attr("id").replace('sliceGroup-', '');
		console.log(charID);
		//turn all selected off
		slices.classed('selected', false);
		svg.select('.chordsBox').selectAll('path').classed('selected', false).classed('core-selected', false);
		svg.selectAll('g.selected-connection').classed('selected-connection', false);
		if (coreState) {
			//turn all selection off
			nodeSelection.classed('core', false);
		}
		else {
			if (selectedState) {
				//turn core on	
				nodeSelection.classed('core', true);
				nodeSelection.classed('selected', true);
				svg.select('g.chordsBox').selectAll('.core.chord-' + charID).classed('core-selected', true).each(function(nodeData) {
					var connectedCharID = getClassName(nodeData.id1) == charID ? getClassName(nodeData.id2) : getClassName(nodeData.id1)
					svg.select('#sliceGroup-' + connectedCharID).classed('selected-connection', true);
				}); //chords
				
			}
			else {
				//turn selected on	
				nodeSelection.classed('selected', true);
				svg.select('g.chordsBox').selectAll('.chord-' + charID).classed('selected', true); //chords
			}
		}
	})

	/* ------- TEXT LABELS -------*/
	var labelBoxes = sliceParents.append('g').classed('label-box', true);
	labelBoxes.append("text")
		.attr("transform", function(d) {
			return "translate(" + textArc.centroid(d) + ")";
		})
		.attr("text-anchor", function(d, i) {
			if (i < dataLength/2)
				return "start";	
			else
			 return "end"; 
		})
		.text(function(d) {
			return d.data.label;
		});

	labelBoxes.append("polyline")
	.attr("points", function(d) {
		return [outsideArc.centroid(d), textArc.centroid(d)];		
	})
	
	/* ----- CHORDS -------*/
	//console.log(connections);
	/*var chordGroups = svg.select('g.chordsBox').selectAll("g")
		.data(connections)
		.enter()
		.append("g")
		.attr("id", function(d) {
			return "chordGroup-" + getClassName(d.name);
		})*/
		
	//only create paths for slices that exist in curr view and don't exist already
	var existingConnections = [];
	for (var j = 0; j < connections.length; j++) {
		var slice1ID = getClassName(connections[j].id1);
		var slice2ID =  getClassName(connections[j].id2);
		var slice1 = svg.select('#sliceGroup-' + slice1ID);
		var slice2 = svg.select('#sliceGroup-' + slice2ID);
		if (slice1.size() + slice2.size() > 1) {
			existingConnections.push(connections[j]);
		}
	}
		
	var chords = svg.select('g.chordsBox').selectAll("path")
		.data(existingConnections)
		.enter()
		.append("path")
		.attr("d", function(d) {
			//console.log(svg.select('g.chordsBox path.chord-' + getClassName(d.id1) + '.chord-' + getClassName(d.id2)).size());
			var startSliceData = svg.select('#sliceGroup-' + getClassName(d.id1)).datum();
			var endSliceData = svg.select('#sliceGroup-'  + getClassName(d.id2)).datum();
			var midPoint = [];
			var startPoint = insideArc.centroid(startSliceData);
			var startBuffer = insideArcLineArc.centroid(startSliceData);
			var endBuffer = insideArcLineArc.centroid(endSliceData);
			var endPoint = insideArc.centroid(endSliceData);
			midPoint[0] = (endBuffer[0] + startBuffer[0])/2;
			midPoint[1] = (endBuffer[1] + startBuffer[1])/2;	
			return arcLine([startPoint, startBuffer, midPoint, endBuffer, endPoint]);			
		})
		.attr("class", function(d) {
			var classes = 'chord-'+getClassName(d.id1) + ' ' + 'chord-'+getClassName(d.id2)
			if (d.type != "standard")
				classes += ' core';
			return classes;
		})
	
};

</script>
</body>